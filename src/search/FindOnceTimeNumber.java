package search;

/**
 * @author coffer
 * @Description : 数组中数字出现的次数(限定是1次)
 * 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。
 * 要求:
 * 时间复杂度是O(n)
 * 空间复杂度是O(1)
 * <p>
 * 示例 1：
 * <p>
 * 输入：nums = [4,1,4,6]
 * 输出：[1,6] 或 [6,1]
 * <p>
 * 示例 2：
 * <p>
 * 输入：nums = [1,2,10,4,1,4,3,3]
 * 输出：[2,10] 或 [10,2]
 * <p>
 * https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/
 * @date 2020/12/12 2:52 下午
 */
public class FindOnceTimeNumber {

    public static void main(String[] args) {
        int a = 4;
        int b = a << 1;
        System.out.println(b);
    }

    /**
     * 使用异或操作来实现：
     * 由于数组中存在着两个数字不重复的情况，我们将所有的数字异或操作起来，
     * 最终得到的结果是这两个数字的异或结果：(相同的两个数字相互异或，值为0)) 最后结果一定不为0，因为有两个数字不重复。
     * <p>
     * 4 ^ 1 ^ 4 ^ 6 => 1 ^ 6
     * <p>
     * 6 对应的二进制： 110
     * 1 对应的二进制： 001
     * 1 ^ 6  二进制： 111
     * <p>
     * 如果我们可以把所有数字分成两组，使得：
     * <p>
     * 两个只出现一次的数字在不同的组中；
     * 相同的数字会被分到相同的组中。
     * 过程：
     * 1、将数字进行分组：我们最容易想到的就是 & 1 操作， 当我们对奇偶分组时，容易地想到 & 1，即用于判断最后一位二进制是否为 1。来辨别奇偶。
     * <p>
     * 首先，两个相同的数字的对应位都是相同的，所以一个被分到了某一组，另一个必然被分到这一组，所以满足了条件 2
     * <p>
     * 算法：
     * 先对所有数字进行一次异或，得到两个出现一次的数字的异或值。
     * <p>
     * 在异或结果中找到任意为 1 的位。
     * <p>
     * 根据这一位对所有的数字进行分组。
     * <p>
     * 在每个组内进行异或操作，得到两个数字。
     *
     * @param nums 目标数组
     * @return 结果
     */
    private static int[] singleNumbers(int[] nums) {
        // k用来计算nums的异或和
        int k = 0;
        // 第一步 ： 将所有数异或起来
        for (int nub : nums) {
            k ^= nub;
        }
        // 获得K中最低位的1
        int mask = 1;
        // 第二步：设置mask为1，则二进制为0001,mask是一个二进制数，且其中只有一位是1，其他位全是0，比如000010，
        // 表示我们用倒数第二位作为分组标准，倒数第二位是0的数字分到一组，倒数第二位是1的分到另一组

        // & operator只有1&1时等于1 其余等于0
        // 用上面的e.g. 4和6的二进制是不同的 我们从右到左找到第一个不同的位就可以分组 4=0100 6=0110
        // 根据e.g. 010 & 001 = 000 = 0则 mask=010
        // 010 & 010 != 0 所以mask=010
        // 之后就可以用mask来将数组里的两个数分区分开
        while ((k & mask) == 0) {
            mask <<= 1;
        }
        // 两个只出现一次的数字
        int a = 0, b = 0;
        for (int nub : nums){
            // 第三步：根据&是否为0区分将两个数字分区，并分别求异或和
            if ((nub & mask) == 0){
                a ^= nub;
            }else {
                b ^= nub;
            }
        }

        // 一位评论分析：
        // 异或满足交换律，第一步异或，相同的数其实都抵消了，剩下两个不同的数。
        // 这两个数异或结果肯定有某一位为1，不然都是0的话就是相同数。
        // 找到这个位，不同的两个数一个在此位为0，另一个为1。
        // 按此位将所有数分成两组，分开后各自异或，相同的两个数异或肯定为0（而且分开的时候，两个数必为一组）。
        // 剩下的每组里就是我门要找的数。

        return new int[]{a, b};
    }
}
